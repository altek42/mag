\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[polish]{babel}
\usepackage{graphicx}
\usepackage[defernumbers=true,backend=bibtex,style=verbose-trad2]{biblatex}
\usepackage{csquotes}
\usepackage{lmodern}  % for bold teletype font
\usepackage{amsmath}  % for \hookrightarrow
\usepackage{xcolor}   % for \textcolor
\usepackage{listings}
\usepackage{caption}

\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listingFormat}{\colorbox{gray}{\parbox{0.98\textwidth}{#3}}}
\captionsetup[lstlisting]{
  format=listingFormat,
  labelfont=white,
  textfont=white
}

\lstset{
  language=C++,
  tabsize=2,
  basicstyle=\footnotesize\ttfamily,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  keywordstyle=\color{blue}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  commentstyle=\color{gray}\ttfamily,
  morecomment=[l][\color{magenta}]{\#}
}

\DeclareQuoteStyle[polish]{polish}
    {\itshape\textquotedblleft}
    [\textquotedblleft]
    {\textquotedblright}
    [0.05em]
    {\textquoteleft}
    {\textquoteright}

\bibliography{bib}
\graphicspath{ {images/} }

\setcounter{page}{3}


\begin{document}
\section*{Streszczenie pracy}
\addcontentsline{toc}{section}{\protect Streszczenie pracy}%
Celem niniejszej pracy dyplomowej...
W skrócie: Stworzyć kompilator który zamieni JavaScript na IL Assembler i będzie można go uruchomić na .NET. Następnie porównanie działania skryptów uruchamianych na maszynach Node.js oraz .NET. Można jeszcze porównać program napisany w C\# z programem napisanym w js.

\hspace{0pt}
\vfill

\section*{Abstract}
\addcontentsline{toc}{section}{\protect Abstract}%
The aim of this diploma thesis was...
\vfill
\hspace{0pt}

\newpage
\tableofcontents
\newpage

% Projekt i implementacja kompilatora języka JavaScript na platformę .NET.

\section{Wstęp}

\par W branży programistycznej istnieje bardzo dużo języków programowania oraz różnych środowisk uruchomieniowych dla nich przeznaczonych. Podczas tworzenia oprogramowania niezbędny jest dla programisty kompilator. Zamienia on kod programu napisanego w konkretnym języku programowania, na zrozumiały dla środowiska uruchomieniowego ciąg instrukcji. Warto podkreślić, że języki programowania, które są proste do zrozumienia i opanowania dla programistów oraz pozwalają na pisanie programów, które można uruchomić na różnych urządzeniach i umożliwiają tworzenie bardzo zróżnicowanych rodzajów oprogramowania, są o wiele częściej używane niż inne. Powoduje to, że powstaje dużo różnych bibliotek i frameworków ułatwiających i automatyzujących tworzenie oprogramowania.

\par Jednym z popularnych języków wśród programistów jest język JavaScript, który może być uruchomiany w przeglądarkach internetowych lub w maszynie wirtualnej takiej jak Node.js. Innym z popularnych środowisk uruchomieniowych jest platforma .NET, dla której istnieje wiele kompilatorów różnych języków. Wykorzystanie istniejących bibliotek, frameworków czy modułów napisanych w języku JavaScript w niezmienionej formie na platformie .NET, umożliwi programistom na tworzenie bardziej uniwersalnego kodu.

\par \textbf{Celem} niniejszej pracy jest \textbf{zaprojektowanie} oraz \textbf{implementacja kompilatora} języka \textbf{JavaScript} na kod \textbf{IL Assembler} uruchamiany na \textbf{platformie .NET}. Następnie w celu sprawdzenia poprawności działania kompilatora, zostaną przeprowadzone testy przy pomocy prostych implementacji kodu JavaScript. Zostaną również zaprojektowane oraz zaimplementowane dwa bardziej skomplikowane testy, do \textbf{porównania maszyn wirtualnych Node.js oraz .NET}. Zostanie także porównany kod assemblera generowanego przez kompilator .Net Core języka C\# z kodem generowanym przez implementowany kompilator.

\par Praca podzielona jest na cztery części. Pierwsza część opisuje pojęcia i technologie wykorzystywane do realizacji tego projektu oraz technologie pokrewne, które w pewnym stopniu realizują cel pracy lub realizują podobne założenia. Druga część poświęcona jest zaprojektowaniu tworzonego kompilatora. Kolejna część opisuje sposób implementacji tego kompilatora na podstawie zdefiniowanych założeń. Ostatnia część opisuje przeprowadzone testy realizowane w ramach pracy oraz przedstawia wyniki ich działania.

\newpage

\section{Pojęcia i technologie}

\subsection{Zakres projektu}
% Wstęp do opisu technologii które będą wykorzystywane w projekcie.

Projekt będzie realizował zaprojektowanie i implementację kompilatora języka JavaScript na platformę uruchomieniową .NET core. W tym rozdziale zostaną opisane pojęcia oraz technologie, które będą wykorzystywane w realizacji tego projektu. Na początku opisane będą takie pojęcia jak \textit{kompilator} oraz \textit{maszyna wirtualna}. Następie zostaną omówione technologie wiodące w projekcie takie jak \textit{JavaScript}, \textit{Node.js}, \textit{.NET Core} oraz \textit{IL Assembler}.

\subsubsection{Kompilator}
W dzisiejszych czasach niezbędnym narzędziem programisty jest kompilator. Jest to narzędzie, którego zadaniem jest tłumaczenie programu napisanego przez programistę, na program który będzie można uruchomić na konkretnym środowisku uruchomieniowym.
\par Mówiąc ściślej kompilator to program napisany w języku implementacyjnym, który odczytuje język źródłowy i tłumaczy go na język wynikowy. Proces zamiany kodu źródłowego na wynikowy nazywany jest \textbf{kompilacją}. Kodem wynikowym procesu kompilacji może być od razu kod maszynowy, który interpretowany jest bezpośrednio przez procesor lub maszynę wirtualną, albo do kodu pośredniego, który też może zostać skompilowany przez inny kompilator.
\par Kompilatory mogą być napisane w dowolnym języku programowania. Istnieje kilka specjalnie zaprojektowanych do tego zadania języków, takie jak \textit{Pascal} czy \textit{Algol 68}. Nie mniej jednak, wybór języka do implementacji kompilatora przez twórcę, powinien się opierać na założeniu, że powinien on zminimalizować wysiłek implementacyjny i zmaksymalizować jakość kompilatora.
\par Język źródłowy który przetwarzany jest przez kompilator prawie zawsze jest oparty na wcześniej zdefiniowanej gramatyce. Dzięki temu program kompilatora potrafi odróżnić od siebie kolejne instrukcje i zamienić je na równoważne ciągi instrukcji w języku docelowym.
\footcite[1-4]{Mckeeman1974}
\par Podobnym w działaniu jest \textbf{interpreter}, który tak jak kompilator, jest pisany w jednym implementacyjnym oraz odczytuje język kodu źródłowego, ale nie produkuje kodu wynikowego, tylko odczytany kod jest od razu wykonywany. Niektóre języki przyjmują schematy zawierające wykorzystanie kompilatora oraz interpretera w procesie wytwarzania oprogramowania. Jednym z przykładów jest język \textbf{Java}, który kompilowany jest do postaci nazywanej \textit{bytecode}, a następnie interpretowany jest przez maszynę wirtualną Java (Java Virtual Machine, JVM).\footcite[3,4]{EngineeringCompiler}

\subsubsection{Maszyna wirtualna}
% https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1430629

\par Wirtualizacja stała się ważnym narzędziem w projektowaniu systemów komputerowych, a maszyny wirtualne używane są w wielu obszarach informatycznych, od systemów operacyjnych po architektury procesorów języków programowania.
\par Dla programistów oraz użytkowników wirtualizacja likwiduje tradycyjne interfejsy oraz ograniczenia zasobów związanych z różnymi urządzeniami. Maszyny wirtualne zwiększają interoperacyjność oprogramowania oraz wszechstronność platformy, dlatego też często się je wykorzystuje.
\par Maszyna wirtualna to nic innego jak program uruchamiany na prawdziwej maszynie, który potrafi obsługiwać pożądaną architekturę. W ten sposób można obejść rzeczywistą kompatybilność maszyny i ograniczenia zasobów sprzętowych. Pozwala to, między innymi na równoczesne tworzenie oprogramowania dla wielu platform, bez konieczności stosowania bezpośrednio interfejsów rzeczywistej maszyny, a jedynie wykorzystanie tych udostępnianych przez maszynę wirtualną. \footcite{Smith2005}

\subsubsection{JavaScript}
Jest to skryptowy język programowania, dzięki którego można realizować aplikacje w paradygmacie imperatywnym, obiektowym oraz funkcyjnym. Najczęściej jest wykorzystywany w stronach internetowych, gdzie kolejne instrukcje wykonywane są przez przeglądarkę sieci Web, ale również zyskuje popularność w innych środowiskach. \footcite{aboutJS}
\par JavaScript został wdrożony w roku 1995 roku, jako sposób dodawania programów do stron internetowych. Jako pierwszą przeglądarką obsługującą JavaScript to Netscape Navigator. Następnie inne, głównie graficzne przeglądarki wprowadzały możliwość uruchamiania kodu napisanego w JavaScript. Umożliwiło to tworzenie nowoczesnych stron internetowych z którymi można było bezpośrednio współpracować, bez konieczności ponownego pobierania strony po każdej wykonanej akcji.
\par W momencie kiedy zaczęto używać JavaScript poza Netscape, został stworzony dokument standaryzujący, który opisuje sposób działania języka. Utworzono go, aby wszystkie nowo tworzone oprogramowanie mające wykorzystywać JavaScript, faktycznie używały tego samego języka. Dokument ten nazywany jest standardem \textbf{ECMAScript}, który został nazwany po organizacji Ecma International, twórców tego dokumentu.
\par JavaScript jest językiem bardzo elastycznym, przez co ma też swoje wady i zalety. Przez swoją elastyczność pozwala na wykorzystywanie wielu technik i praktyk programistycznych które mogą być niemożliwe w innych językach.
\par Jako, że jest to język skryptowy, to tak jak podobne tego typu języki posiada dynamiczne typowanie zmiennych. Oznacza to, że każda ze zmiennej jest definiowana poprzez słowo kluczowe \texttt{var}, a w nowszej wersji można to zrobić już przy pomocy dwóch różnych słów \texttt{const} oraz \texttt{let}. Kolejną z podstawowych rzeczy w JavaScript są funkcje. Dzięki nim można pisać programy we wspomnianych wcześniej paradygmatach. Pozwalają one nie tylko na wydzielenie kodu na mniejsze części ale również na definiowanie bardziej złożonych struktur czy klas.\footcite{EloquentJavaScript}
% https://eloquentjavascript.net/Eloquent_JavaScript.pdf

\subsubsection{Node.js}
Jest to asynchroniczne środowisko uruchomieniowe dla języka JavaScript. Node.js został zaprojektowany do tworzenia skalowalnych aplikacji sieciowych. Pozwala na jednoczesne przetwarzanie wielu połączeń. Przy każdym połączeniu następuje wywołanie zwrotne, a w przypadku jeśli nie będzie żadnej pracy do wykonania, Node.js przejdzie w tryb uśpienia.
\footcite{Node.js2017}

\par Środowisko Node.js oparte jest na implementacji silnika ``V8'' stworzonego przez Google. Zaimplementowany głownie jest w języku C i C++, koncentrując się na wydajności i niskim zużyciu pamięci. Różnica polega na tym, że silnik ``V8'' obsługuje głównie JavaScript w przeglądarkach internetowych, a Node.js został stworzony z myślą o obsłudze długotrwałych procesów serwerowych.
\par W celu obsługi jednoczesnego wykonywania logiki biznesowej, Node.js opiera się na asynchronicznym modelu zdarzeń wejścia i wyjścia, w przeciwieństwie do większości innych współczesnych środowisk, które oparte są na wielowątkowości. Model zdarzeń jest obsługiwany na poziomie języka, a jest to możliwe ponieważ JavaScript obsługuje wywołania zwrotne zdarzeń oraz funkcjonalny charakter JavaScript sprawia, że niezwykle łatwo jest tworzyć anonimowe obiekty funkcji, które można zarejestrować jako programy obsługi zdarzeń. \footcite{Tilkov2010}

\subsubsection{.NET Core}

\par Jest to platforma programistyczna ogólnego zastosowania z otwartymi kodami źródłowymi. Pozwala na tworzenie aplikacji dla systemów Windows, macOS oraz Linux przy wykorzystaniu różnych języków programowania.\footcite{dotNetvsFramework}
\par Architektura środowiska .NET składa się z takich komponentów jak:
\begin{itemize}
  \item CTS (Common Type System) - opisuje wszystkie wspierane przez platformę typy. Definiuje zasady korzystania z danych typów, dostarcza zorientowany obiektowo model dla różnych języków implementowanych w .NET oraz zapewnia bibliotekę zawierającą prymitywne typy danych (takich jak \texttt{Boolean}, \texttt{char} itp.).
  \item CLS (Common Language Specyfication) - definiuje w jaki sposób mają być definiowane obiekty i funkcje, w języku przeznaczonym na platformę .NET. CLS jest podzbiorem CTS, co oznacza, że wszystkie opisane zasady CTS dotyczą również CLS.\footcite{dotNetCLS}
  \item FCL (Framework Class Library) - jest to standardowa biblioteka zawierająca podstawę implementacji klas, interfejsów, typów wartości czy usług, które wykorzystywane są do tworzenia aplikacji.\footcite{dotNetFCL}
  \item CLR (Common Language Runtime) - jest to środowisko uruchomieniowe, które uruchamia kod i zapewnia usługi ułatwiające proces programowania. Środowisko wykonawcze automatycznie obsługuje układ obiektów i zarządza referencjami no nich, zwalniając je w przypadku kiedy już nie są używane.\footcite{dotNetCLR}
  
\end{itemize}

\subsubsection{IL Assembler}
\par Każdy z kompilatorów przeznaczonych na platformę .NET, bez względu na wybrany język, kompiluje kod do postaci pośredniej, jakim jest kod IL.
\par Wykonywalny kod IL jest w formacie binarnym i nie jest czytelny dla człowieka. Oczywiście jak inne wykonywalne kody binarne, mogą zostać przedstawione w postaci assemblera, tak i kod IL może zostać zaprezentowany w postaci IL Assemblera. Zestaw instrukcji jest taki jak w przypadku tradycyjnego assemblera. Przykładowo, aby dodać dwie liczby należy użyć instrukcji \texttt{add}, a w przypadku odejmowania, należy użyć instrukcji \texttt{sub}.
\par Środowisko uruchomieniowe .NET nie potrafi jednak odczytywać bezpośrednio IL Assemblera. Aby kod napisany w IL Assemblerze można było uruchomić, trzeba skompilować go do postaci binarnej IL. \footcite{ILAsm1}

\subsection{Technologie pokrewne}
W tej sekcji będą przedstawione technologie pokrewne.
Najpierw technologie konkurencyjne, następnie istniejące rozwiązania a na końcu rozwiązania podobne/nawiązujące w jakiś sposób do tematu.

\subsubsection{ECMAScript}
W sumie jest to standard języka na podstawie którego definiowana jest składnia JavaScript. Czy warto o tym wspominać?

\subsubsection{ActionScript}
Obiektowy język oparty na ECMAScript używany w Adobe Flash/

\subsubsection{JScript}
Jest to implementacja JavaScript przez Microsoft która jest uruchomiana w środowisku .NET.
Istnieją pewne różnice w porównaniu do JavaScript.

\subsubsection{TypeScript}
Język programowania stworzony przez Microsoft. Uruchamiany na Node.js lub Deno. Może być przekompilowany do js es5 przez Babel.

\subsubsection{?CoffeeScript}
Język programowania kompilowany do JavaScript.
Nie wiem czy warto wspominać.

Inne języki kompilowane do JavaScript: Roy, Kaffeine, Clojure, Opal

\subsubsection{Babel}
Kompiluje przykładowo TypeScript do JavaScript lub JavaScript ES6 do ES5.

% Maszyna inna niż Node.js
\subsubsection{Deno}
Maszyna wirtualna dla języka JavaScript oraz TypeScript.
% Nie jestem pewien czy można na "żywca" uruchamiać na niej TypeScript. (Temat do sprawdzenia)

\subsubsection{asm.js}
Jeśli dobrze zrozumiałem jest to okrojony JavaScript który tak samo może być uruchamiany w przeglądarkach czy Node.js/Deno.
Wykorzystywany przy kompilacji kodu c++ do uruchamiania na tych maszynach.

\subsubsection{Emscripten}
% https://pl.wikipedia.org/wiki/Emscripten
Kompilator kodu LLVM do JavaScript.

\subsubsection{WebAssembly}
% https://devenv.pl/webassembly-nadciaga-rewolucja/
Język niskopoziomowy, który działa z szybkością zbliżoną do rozwiązań natywnych i pozwala na kompilację kodu napisanego w C/C++ do kodu binarnego działającego w przeglądarce internetowej.
(Pomija JavaScript).

\subsubsection{C\#}
Czy opisywać rodzinę .NET?

Na maszynę .NET istnieją implementacje języków takich jak Python, Java, C++ i inne.

\subsubsection{.NET Framework}
Platforma programistyczna.

\subsubsection{Mono}
Implementacja open source platformy .NET Framework.

\subsubsection{DotGNU}
Alternatywa dla Mono.

\subsubsection{?Roslyn}
.NET Compiler Platform


\section{Projekt kompilatora}
Opis 
\subsection{Środowisko i narzędzia}
Opis sprzętu na którym będzie wszystko uruchomiane.
Do implementacji będą wykorzystane:

\begin{itemize}
  \item C\#
  \item Visual Studio Code
  \item WSL (Ubuntu 20.04 LTS)
  \item JavaScript
  \item Node.js
  \item mono-devel (ilasm, ildasm)
\end{itemize}

\subsection{Analiza języka JavaScript i określenie zakresu implementacji}
% Opis składni JavaScript.
% Implementacja JavaScript w standardzie ES5.
% Musi być Turing-complete. Dodatkowo implementacja funkcji.

\par W tym rozdziale zawarty zostanie zakres implementacji oraz opis poszczególnych elementów języka JavaScript. W projekcie zostanie zaimplementowana jedynie część standardu ECMAScript, a niektóre mechanizmy zostaną uproszczone.

% #PYTANIE Czy warto opisać rzeczy które nie będą implementowane?

\subsubsection{Wyrażenia}

\par Składnia języka JavaScript zapożycza wiele rozwiązań użytych w Javie, jednak na konstrukcję miły też wpływ takie języki jak: Awk, Perl i Python. W języku JavaScript instrukcję nazywane są wyrażeniami, które rozdzielane są znakiem średniaka. Znaki białe takie jak spacja, tabulator czy znak końca linii nie mają wpływu na sposób działania kolejnych elementów wyrażeń, stanowią jedynie sposób ich oddzielenia. W kodzie źródłowym JavaScript rozróżnialna jest wielkość liter oraz wspierany jest standard znaków Unicode. ECMAScript definiuje również zestaw słów kluczowych i literałów oraz zasady automatycznego umieszczania średników ASI (Automatic semicolon insertion).

\subsubsection{Komentarze}

\par Rozróżniane są dwa typy komentarzy:
\begin{enumerate}
  \item Jednoliniowy - definiowany jest przy pomocy znaku \enquote{$\backslash\backslash$} oraz umieszczany jest na końcu linii.
  \begin{lstlisting}
    console.log(); \\ komentarz
  \end{lstlisting}
  \item Wieloliniowy - zawarty jest pomiędzy dwoma elementami \enquote{/*} oraz \enquote{*/}
  \begin{lstlisting}
    console.log();
    /*
      komentarz na
      wiele linii
    */
  \end{lstlisting}
\end{enumerate}

\subsubsection{Deklaracje zmiennych i stałych}
\par Zmienne deklaruje się przy pomocy słów kluczowych \texttt{var}, \texttt{let} oraz \texttt{const}. Deklaracja przy pomocy \texttt{var} jest podstawowym sposobem tworzenia zmiennych w JavaScript. Zasięg takiej zmiennej nie może być ograniczony przez blok w którym jest zawarta, przez co może powodować błędy przy pisaniu kodu. W celu uściślenia zasięgu i przeznaczenia zmiennych powstały dwa inne sposoby deklaracji \texttt{let} oraz \texttt{const}. Oba te rodzaje deklaracji powodują, że zakres dostępności zmiennej jest ograniczony do bloku w którym została zadeklarowana. Różnicą między tymi dwoma deklaracjami jest taka, że przy pomocy \texttt{const} definiujemy stałą która musi być od razu zadeklarowana, a \texttt{let} działa podobnie jak \texttt{var}.
\begin{lstlisting}
  var zmienna1;
  let zmienna2;
  const stala = true;
\end{lstlisting}
\par Przy deklaracji zmiennych przy użyciu \texttt{var} lub \texttt{let}, których nie przypiszemy żadnej wartości to przyjmują one wartość \texttt{undefined}

\subsubsection{Typy danych}
\par W najnowszym standardzie ECMAScript zdefiniowanych jest siedem typów danych:
\begin{enumerate}
  \item \texttt{Boolean} - może przybierać dwie wartości \texttt{true} lub \texttt{false}.
  \item \texttt{null} - słowo kluczowe oznaczające wartość zerową. 
  \item \texttt{undefined} - wartość nieokreślona.
  \item \texttt{Number} - tym przeznaczony dla literałów całkowitych jak i zmiennoprzecinkowych.
  \item \texttt{String} - typ przeznaczony dla literałów łańcuchowych reprezentujących zero lub więcej pojedynczych znaków ujętych w podwójny lub pojedynczy cudzysłów.
  \item \texttt{Symbol} - wprowadzony w ECMAScript 6 typ danych, który pozwala na tworzenie unikalnych i nie zmiennych wartości.
  \item \texttt{Object} - typ złożony do którego zaliczają się funkcje, tablice, słowniki oraz instancje klas.
\end{enumerate}

\subsubsection{Operacje arytmetyczne}
\subsubsection{Operacje warunkowe}
\subsubsection{Zakres implementacji projektu}
W niniejszym projekcie zostaną zaimplementowane następujące elementy: 
\begin{itemize}
  \item Komentarze jednoliniowe oraz wieloliniowe.
  \item Proste typy danych: \texttt{Boolean}, \texttt{Number}, \texttt{String}.
  \item Tworzenie zmiennych typu \texttt{var}.
  \item Uproszczona implementacja funkcji \texttt{console.log()}.
  \item Konwersja typów danych.
  \item Operacje matematyczne takie jak dodawanie, odejmowanie, mnożenie oraz dzielenie.
  \item Wyrażenia warunkowe takie jak sprawdzenie: równości, nierówności, większości lub mniejszości.
  \item Typ \texttt{Object} pod postacią tablicy elementów oraz słownika danych.
  \item Deklaracja oraz wywoływanie funkcji: bez parametrów oraz zwracanej wartości, bez parametrów oraz z zwracaną wartością, z parametrami bez zwracanej wartości oraz z parametrami z zwracaną wartością.
\end{itemize}

% https://developer.mozilla.org/pl/docs/Web/JavaScript/Guide/Sk%C5%82adnia_i_typy

\subsection{Parser}
Używamy ANTLR z własną gramatyką ale posiłkując się gotowcem. Wykorzystanie gotowej gramatyki powoduje wygenerowanie tak dużych plików, że próba zrozumienia co jest do czego wymaga poświęcenia dużego wysiłku. Większość tych rzeczy i tak by nie została wykorzystana.

Rozważane możliwości i wykonano przegląd narzędzi:

po 2 zdania: \\
Gotowe narzędzia:
\begin{itemize}
  \item LEX \& YYAC
  \item ANTLR
  \item Coco/R
  \item gppg \& gplex
  \item Owl (https://github.com/ianh/owl)
\end{itemize}
i więcej... https://en.wikipedia.org/wiki/Comparison\_of\_parser\_generators


\subsection{Struktura projektu}
Diagramy i opisy.
Jak będzie wyglądał ten rozdział zależy jak wyjdzie implementacja.
% Tak, tak, wiem, najpierw implementacja a później dokumentacja...

\section{Implementacja aplikacji kompilatora}
\subsection{Parser}
Sposób implementacji lub przygotowania i użycia gotowych narzędzi.

\subsection{Analiza leksykalna}
Tekst
\subsection{Gramatyka}
Tekst
\subsection{Funkcjonalności}
Opis sposobu przetwarzania instrukcji
\subsection{Generowanie assemblera}
Opisać jak wygenerować kod .NET

\section{Testy}
Opis zakresu testów i jak będą przebiegać.
Każdy z poniższych testów będzie sprawdzany pod kątem poprawności wykonywania działań, czasu wykonywania w porównaniu do wykonania kodu na Node.js (dla bardziej złożonych testów z czasem będzie więcej), zajętość pamięci (również tylko przy tych których to ma sens) oraz porównaniu kodu z asemblerowego wygenerowanego za pośrednictwem języka C\#.

\subsection{Proste operacje matematyczne}
Test dodawania, odejmowania, mnożenia, dzielenia, przypisywania.
\subsection{Kolejność wykonywania działań}
Test na bardziej złożonych wyrażeniach. Sprawdzenie poprawności działania nawiasów oraz kolejności wykonywania działań.
\subsection{Wyrażenia warunkowe}
Test wyrażeń warunkowych. Kolejność wykonywania operacji and i or.
\subsection{Tablice}
Test obsługi tablic jedno i wielowymiarowych.
\subsection{Obiekty}
Test obsługi obiektów.
\subsection{Klasy}
Jeśli będzie implementacja.
Test działania obiektów klas.
\subsection{Funkcje}
Test działania funkcji.
1. Funkcja "void" bez parametrów.
2. Funkcja "void" z parametrami.
3. Funkcja zwracająca różne typy (proste, tablice, obiekty) bez parametrów.
4. Funkcje zwracająca różne typy z parametrami.
5. inne

\subsection{Algorytm 1}
\subsubsection{Opracowanie pseudokodu algorytmu 1}
\subsubsection{Implementacja algorytmu 1}
\subsubsection{Testy algorytmu 1}
\subsection{Algorytm 2}
\subsubsection{Opracowanie pseudokodu algorytmu 2}
\subsubsection{Implementacja algorytmu 2}
\subsubsection{Testy algorytmu 2}

% Inne testy to pokazanie wygenerowanego kodu, ciekawy testem może być disassemblacja do kodu C\# przy pomocy jakiegoś narzędzia (np. dotPeek). Ponadto można sprawdzić (przy dużych rozmiarach danych użytych w algorytmie) zajętość pamięci.

\section{Podsumowanie}


\newpage
\printbibliography[heading=bibintoc]

\end{document}
