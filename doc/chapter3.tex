\chapter{Implementacja aplikacji kompilatora}
\label{rozdzial3}

\section{Parser}
\par W projekcie zostanie wykorzystane narzędzie ANTLR, które można z następującego linku \url{https://www.antlr.org/download.html} (dostępne: 28.05.2021). Należy wydzielić osobny folder w którym będą znajdować się pliki z definicjami leksemów oraz gramatyki. Do danego folderu należy przenieść plik wykonywalny (\textit{antlr.jar}) narzędzia ANTLR. Aby uruchomić narzędzie wymagane jest posiadanie środowiska wykonawczego Java.
\par W celu wygenerowania plików parsera dla środowiska .NET należy wywołać komendę przedstawioną w algorytmie \ref{alg:antlr}. W folderze w którym zostanie wykonana komenda znajdują się aktualnie dwa pliki: 
\begin{itemize}
  \item \textit{JavaScriptLexer.g4} - plik zawierający definicję leksemów
  \item \textit{JavaScriptParser.g4} - plik zawierający definicję gramatyki
\end{itemize}
Po wykonaniu komendy generowania, powstaną cztery pliki wynikowe: 
\begin{itemize}
  \item \textit{JavaScriptLexer.cs}
  \item \textit{JavaScriptParser.cs}
  \item \textit{JavaScriptParserBaseListener.cs}
  \item \textit{JavaScriptParserListener.cs}
\end{itemize}
Są to pliki kodu źródłowego parsera dla zdefiniowanych wcześniej leksemów oraz gramatyki. W celu użycia parsera, należy utworzyć własną klasę, która będzie dziedziczyć po klasie \textit{JavaScriptParserBaseListener} zawierająca definicje nagłówków funkcji.

\begin{lstlisting}[caption=Komenda uruchamiająca narzędzie ANTLR, label=alg:antlr]
  java -jar antlr.jar -Dlanguage=CSharp *.g4
\end{lstlisting}

\subsection{Analiza leksykalna}
\par W celu przeanalizowania pliku wejściowego kodu JavaScript pod kątem leksykalnym i utworzeniu tokenów, należy zdefiniować odpowiednie reguły w pliku \textit{JavaScriptLexer.g4}. 
\par Na samym początku pliku musi się znajdować deklaracja, że ten plik zawiera reguły do analizy leksykalnej. 

\begin{lstlisting}[caption=Deklaracja pliku do analizy leksykalnej, label=alg:antlrLex1]
  lexer grammar JavaScriptLexer;
\end{lstlisting}

Następnie w pliku powinny się znajdować reguły tokenów. Definiuje się je, nadając nazwę tokenu, a po dwukropku wpisuje się jedno lub wiele wyrażeń dopasowania oddzielonymi znakami `|'. Nazwy tokenu muszą zaczynać się wielką literą.


\begin{lstlisting}[caption=Przykład definicji tokenów dla znaków operacji porównania, label=alg:antlrLex2]
  LESS_THAN:           '<';
  MORE_THAN:           '>';
  LESS_THAN_EQUALS:    '<=';
  GREATER_THAN_EQUALS: '>=';
  EQUALS:              '==';
  NOT_EQUALS:          '!=';
  IDENTITY_EQUALS:     '===';
  IDENTITY_NOT_EQUALS: '!==';
\end{lstlisting}

\begin{lstlisting}[caption=Przykład definicji tokenów dla znaków słów kluczowych, label=alg:antlrLex3]
  CONSOLE_LOG: 'console.log';
  VAR:         'var';
  CONTINUE:    'continue';
  FOR:         'for';
  WHILE:       'while';
  FUNCTION:    'function';
  LENGTH:      'length';
  RETURN:      'return';
\end{lstlisting}

\par Można również zdefiniować regułę pomocniczą, która nie będzie interpretowana jako token, ale jej dopasowanie będzie uwzględniane, przy wykorzystaniu jej w innej regule. Aby stworzyć taką regułę pomocniczą, należy użyć instrukcji \texttt{fragment} przed nazwą tokenu.

\begin{lstlisting}[caption=Przykład definicji tokenu dla wielu dopasowań, label=alg:antlrLex4]
  NUMBER
  : INTEGER_NUMBER '.' [0-9] [0-9_]*
  | '.' [0-9] [0-9_]*
  | INTEGER_NUMBER
  ;

fragment INTEGER_NUMBER
  : '0'
  | '-'?[1-9] [0-9_]*
  ;
\end{lstlisting}

% https://sodocumentation.net/antlr/topic/3271/lexer-rules-in-v4
\par Można również zdefiniować regułę, która zamiast tworzyć token, będzie dane dopasowanie pomijać. Aby tego dokonać, trzeba dołączyć do danej reguły, wywołanie komendy leksera \texttt{skip}. Istnieją również inne komendy takie jak: \texttt{channel(n)} - służący do zmiany kanału emitowanych tokenów; \texttt{type(n)} - zmieniający typ tokenu; \texttt{mode(n)}, \texttt{pushMode(n)}, \texttt{popMode}, \texttt{more} - kontrolujące tryb działania leksera. \footcite{AntlrLexRules}

\begin{lstlisting}[caption=Przykład użycia komendy \texttt{skip}, label=alg:antlrLex5]
  MULTI_LINE_COMMENT:  '/*' .*? '*/'   -> skip;
\end{lstlisting}

\subsection{Gramatyka}
Po zdefiniowaniu tokenów, można rozpocząć definicję gramatyki. Tak jak było w przypadku pliku z leksemami, należy w pliku \textit{JavaScriptParser.g4} zadeklarować, że plik zawiera reguły gramatyki oraz również wskazać plik zawierający tokeny.

\begin{lstlisting}[caption=Deklaracja pliku do analizy gramatyki, label=alg:antlrGr1]
  parser grammar JavaScriptParser;

  options {
    tokenVocab=JavaScriptLexer;
  }
\end{lstlisting}

Definicje gramatyk deklaruje się w identyczny sposób jak tworzyło tokeny. Najpierw należy podać nazwę reguły a pod dwukropku, podajemy jedna lub wiele definicji oddzielonymi znakiem `|'. Zdefiniowana gramatyka może być wykorzystana w innych definicjach. 

\begin{lstlisting}[caption=Przykład definicji reguły gramatyki, label=alg:antlrGr1]
  booleanValue
  : BOOLEAN
  ;

  constantValue
  : booleanValue
  | stringValue
  | numberValue
  ;
\end{lstlisting}

\par Dla każdej zdefiniowanej reguły, przy pomocy narzędzia ANTLR, zostaną utworzone dwie funkcję w wygenerowanym pliku parsera. Pierwsza będzie się wykonywać przed, a druga po analizie reguł. Nazwy wygenerowanych funkcji będą identyczne jak nazwa reguły z dopisanym przedrostkiem \textit{Enter} dla funkcji wywoływanej przed analizą reguły oraz \textit{Exit} dla funkcji po analizie. Jako argument funkcji jest przekazywany kontekst parsera, dzięki któremu można pobrać wartość leksemu, lub też sprawdzić która definicja jest analizowana.

\begin{lstlisting}[language=CSharp, caption=Przykład wygenerowanych funkcji gramatyki parsera, label=alg:antlrGr2]
  /// <summary>
  /// Enter a parse tree produced by <see cref="JavaScriptParser.constantValue"/>.
  /// <para>The default implementation does nothing.</para>
  /// </summary>
  /// <param name="context">The parse tree.</param>
  public virtual void EnterConstantValue([NotNull] JavaScriptParser.ConstantValueContext context) { }
  /// <summary>
  /// Exit a parse tree produced by <see cref="JavaScriptParser.constantValue"/>.
  /// <para>The default implementation does nothing.</para>
  /// </summary>
  /// <param name="context">The parse tree.</param>
  public virtual void ExitConstantValue([NotNull] JavaScriptParser.ConstantValueContext context) { }
\end{lstlisting}

\par Domyślna implementacja wygenerowanych metod, nie posiadają żadnych instrukcji, dlatego też nie trzeba pisać własnych implementacji dla każdej z reguł. W przypadku kiedy chcemy napisać implementacje tych metod, jak było wcześniej wspominane, trzeba stworzyć własną klasę dziedziczącą po wygenerowanej klasie i podać jej instancję, jako klasa nasłuchująca (\textit{listner}) dla parsera.

\section{Kompilator}

\par Program kompilatora wymaga podania jednego argumentu, który jest ścieżką do pliku źródłowego, zawierającego kod JavaScript. Jego wynikiem jest plik o tej samej nazwie z rozszerzeniem ``\textit{.il}'' zawierający kod assemblera platformy .NET. Zawartość pliku źródłowego jest analizowana przez parser, który wywołuje odpowiednie metody przy dopasowaniu reguł gramatyki.
\par W funkcji głównej \textit{Main} kompilatora znajduje się: otwarcie pliku źródłowego, utworzenie instancji modułu do generowania pliku wyjściowego, konfiguracja wcześniej wygenerowanego parsera oraz jego uruchomienie. Po zakończeniu analizy pliku źródłowego, plik jest zamykany, a następnie tworzony jest plik wyjściowy.

\begin{lstlisting}[language=CSharp, caption=Funkcja \textit{Main} kompilatora, label=alg:komMain]
  static void Main(string[] args) {
    if (args.Length < 1) {
      throw new ArgumentException("Needs file name as argument");
    }

    using (AsmGenerator.Create(args[0])) {
      using (FileStream fs = File.OpenRead(args[0])) {
        AntlrInputStream imputStream = new AntlrInputStream(fs);
        JavaScriptLexer lexer = new JavaScriptLexer(imputStream);
        CommonTokenStream commonTokenStream = new CommonTokenStream(lexer);
        JavaScriptParser parser = new JavaScriptParser(commonTokenStream);
        parser.BuildParseTree = true;
        JavaScriptParser.ParseContext context = parser.parse();

        JavaScriptListner listner = new JavaScriptListner();
        ParseTreeWalker walker = new ParseTreeWalker();
        walker.Walk(listner, context);
      }
    }
    Console.WriteLine("Done.");
  }
\end{lstlisting}

\subsection{Wywołania parsera}

Do przechwytywania reguł gramatyki została utworzona klasa o nazwie \textit{JavaScriptListner} dziedzicząca po wygenerowanej klasie \textit{JavaScriptParserBaseListener}. Zawiera ona nadpisane metody parsera w których wywoływane są odpowiednie funkcje z modułów obsługujących funkcjonalności. Funkcjonalności zostały podzielone na moduły i przeniesione do osobnych klas, ze względu na czytelność kodu.
\par Niektóre z funkcji wywołują jedynie funkcjonalność modułu, a inne sprawdzają dodatkowe warunki na podstawie dostarczonego kontekstu. Są przypadki gdzie, trzeba sprawdzić która z definicji reguł jest analizowana i w zależności od tego wywołać odpowiednią metodę z konkretnego moduł.

\begin{lstlisting}[language=CSharp, caption=Przykład prostej funkcji listnera, label=alg:komListner1]
  public override void ExitIfStatement(JavaScriptParser.IfStatementContext context)
  {
    conditionModule.EndIfStatement();
  }
\end{lstlisting}

\par Klasa \textit{JavaScriptListner} ma również za zadanie przy pomocy kontekstu, pobierać nazwy oraz wartości znajdujące się w pliku źródłowym dla konkretnych reguł. Przykładowo musi pobrać nazwę deklarowanej zmiennej lub też przypisywanej do niej wartości.

\begin{lstlisting}[language=CSharp, caption=Przykład funkcji listnera z sprawdzeniem kontekstu, label=alg:komListner2]
  public override void ExitIdentifierValue(JavaScriptParser.IdentifierValueContext context) {
    string value = context.GetChild(0).GetText();
    if(context.ChildCount > 1) {
      arrayModule.CreateTableVariable(value);
    } else {
      variableModule.CreateVariable(value);
    }
  }
\end{lstlisting}

\subsection{Zarządzanie stosem zmiennych}

\par W celu zarządzania oraz przechowywania informacji o wartościach kodu źródłowego, została utworzona statyczna klasa \texttt{Store}. Zawiera ona następujące elementy:
\begin{itemize}
  \item \texttt{Stack} - stos główny kompilatora
  \item \texttt{LabelStack} - stos indexów dla nazw instrukcji warunkowych oraz pętli
  \item \texttt{FunctionCallArgCounterStack} - stos służący do zliczania argumentów funkcji
  \item \texttt{\_labelStackCounter} - licznik indexów etykiet
  \item \texttt{Variables} - słownik zdefiniowanych zmiennych
  \item \texttt{Functions} - słownik informacji definiowanych funkcji
  \item \texttt{ProcessingFunction} - nazwa aktualnie przetwarzanej funkcji.
\end{itemize}
\par Elementem który przechowuje główny stos oraz słownik zmiennych jest klasa \texttt{StoreItem}. Zawiera on niezbędne informacje o przetwarzanym elemencie. Dzięki tej klasie można przechować następujące informacje:
\begin{itemize}
  \item \texttt{ItemType} - definiuje czy dany element jest zmienną o danym typie, zmienną tablicową, elementem tablicy, argumentem funkcji czy znakiem arytmetycznym lub porównania.
  \item \texttt{IsVariable} - definiuje czy element jest zmienną
  \item \texttt{IsTemporary} - definiuje czy element jest zmienną tymczasową
  \item \texttt{IsInitialized} - definiuje czy zmienna jest dopisana do listy do zainicjalizowania
  \item \texttt{IsFunctionParam} - definiuje czy zmienna jest parametrem funkcji
  \item \texttt{ParamPosition} - definiuje pozycję w liście argumentów funkcji
  \item \texttt{Parent} - element z którego powstał dany element
  \item \texttt{TableIndex} - index zmiennej tablicowej
\end{itemize}

\par Dla słownika informacji dla zdefiniowanych funkcji została stworzona klasa \texttt{FunctionStore}. Przechowuje ona:
\begin{itemize}
  \item \texttt{Variables} - słownik zmiennych lokalnych funkcji
  \item \texttt{Params} - słownik parametrów funkcji
  \item \texttt{Name} - nazwę funkcji
  \item \texttt{IsUsed} - informacje, czy dana funkcja została wywołana co najmniej raz
  \item \texttt{ReturnValue} - wartość zwracana przez funkcję
\end{itemize}

\subsection{Moduły}

Każdy z modułów wykorzystuje \texttt{Store} do przetwarzania instrukcji kodu źródłowego i wywołuje odpowiednie funkcje klasy generującej kod assemblera. Moduły zostały podzielone ze względu na grupy implementowanych funkcjonalności.

\subsubsection{Obsługa standardowego wyjścia}

W JavaScript funkcją wyświetlającą tekst na standardowym wyjściu (konsoli) służy funkcja \texttt{log()} z standardowej klasy \texttt{console}. Jako że założony zakres implementacji kompilatora nie uwzględnia implementacji klas, wywołanie tej funkcji zostało zdefiniowane jako słowo kluczowe. Dzięki temu zabiegowi można zasymulować wywołanie tej metody, jakby rzeczywiście została wywoływana ze standardowej klasy.

\begin{lstlisting}[caption=Definicja gramatyki dla funkcji standardowego wyjścia, label=alg:consolelogGram]
  writeStdOutput
  : CONSOLE_LOG OPEN_PAREN constantValue CLOSE_PAREN
  | CONSOLE_LOG OPEN_PAREN identifierValue CLOSE_PAREN
  | CONSOLE_LOG OPEN_PAREN arithmeticOperation CLOSE_PAREN
  | CONSOLE_LOG OPEN_PAREN functionCall CLOSE_PAREN
  ;
\end{lstlisting}

\par Zostały zdefiniowane cztery gramatyki dla różnych rodzajów parametrów: wartości stałej (takich jak liczby, czy ciągi znaków), zmiennej, operacji arytmetycznej oraz wywołania funkcji.

\par Po realizacji definicji gramatyki parametru, zostanie zawsze odłożona na główny stos wartość którą chcemy wyświetlić na konsoli. W tym celu używana jest funkcja o nazwie \texttt{WriteStdOutput} z modułu \texttt{ConsoleModule}. Ściąga ona ze stosu wartość, a następnie w zależności od tego, czy jest to zmienna tablicowa wywołuje odpowiednią funkcję generatora assemblera.

\begin{lstlisting}[language=CSharp, caption=Definicja gramatyki dla funkcji standardowego wyjścia, label=alg:consolelogMdoule]
  public void WriteStdOutput(){
    StoreItem item = Store.PopStack();
    if(item.IsType(StoreItemType.ARRAY)){
      asmGenerator.WriteArrayToStdOutput(item);
    }else {
      asmGenerator.WriteToStdOutput(item);
    }
    asmGenerator.EmptyLine();
  }
\end{lstlisting}

\par Wyświetlenie pojedynczej wartości wymaga jedynie wygenerowania kodu ładującego daną wartość na stos oraz wywołanie odpowiedniej funkcji do wyświetlenia. W przypadku tablic został zastosowany zabieg, polegający na połączenie wszystkich elementów w ciąg znaków i wyświetlenie otrzymanej wartości na ekranie.

\begin{lstlisting}[language=IL, caption=Przykład wygenerowanego kodu assemblera dla funkcji wyjścia standardowego, label=alg:consolelogAsm]
  // Wyświetlenie pojedynczej wartości
  ldstr "tekst 123"
  call void [mscorlib]System.Console::WriteLine(string)

  // Wyświetlenie tablicy
  ldstr   "["
  ldstr   ", "
  ldloc v_tab
  call string [mscorlib]System.String::Join<int32>(string, class [mscorlib]System.Collections.Generic.IEnumerable`1 <!!0/*int32*/>)
  ldstr   "]"
  call string [mscorlib]System.String::Concat(string, string, string)
  call void [mscorlib]System.Console::WriteLine(string)
\end{lstlisting}

\subsubsection{Obsługa zmiennych}

\par Moduł obsługi zmiennych obejmuje funkcjonalności związanych z definicją elementów stałych, zmiennych, obsługi deklaracji zmiennych oraz obsługi rzutowania typów zmiennych. \par Przy analizowaniu reguły gramatyki identyfikującej liczbę, ciąg znaków, wartość liczbową, czy nazwę identyfikatora, wywoływane są dla nich odpowiednie metody które utworzą element opisujący dane wartości i dopiszą je na szczyt głównego stosu. Deklaracja zmiennych przebiega w ten sam sposób, ponieważ przypisanie do listy zmiennych następuje przy pierwszym wystąpieniu przypisania wartości do danej zmiennej. Przy tych operacjach nie jest tworzony kod asemblerowy.

\begin{lstlisting}[language=CSharp, caption=Implementacja funkcji tworzącej element opisujący stałą liczbową, label=alg:variable1]
  public void CreateNumber(string value) {
    StoreItem item;
    if (value.Contains(".")) {
      item = StoreItem.CreateDouble(value);
    } else {
      item = StoreItem.CreateInteger(value);
    }
    Store.PushStack(item);
  }
\end{lstlisting}

\par W tym module znajduje się jeszcze funkcjonalność rzutowania typów zmiennych. Jest ona potrzebna, ponieważ język JavaScript jest językiem z dynamicznym typowaniem zmiennych i pozwala na operacje na różnych typach zmiennych. Funkcjonalność jest wykorzystywana przykładowo przy operacjach arytmetycznych, kiedy chcemy dodać do siebie wartość całkowitą do wartości rzeczywistej. W takim przypadku następuje rzutowanie zmiennej całkowitej na zmienną rzeczywistą.
\par Funkcja rzutowania przyjmuje jako argument element opisujący zmienną oraz typ docelowy. Na podstawie dostarczonego elementu tworzona jest jego kopia, następnie nowa zmienna jest inicjalizowana poprzez dopisanie jej do listy zadeklarowanych zmiennych. Na końcu wywoływana jest funkcja generująca kod assemblera, służąca do rzutowania wartości.

\begin{lstlisting}[language=CSharp, caption=Implementacja funkcji rzutującej zmienne, label=alg:variable2]
  public StoreItem CastVariable(StoreItem item, StoreItemType itemType){
    if(item.ItemType == itemType){
      return item;
    }

    StoreItem vessel = item.CreateCastVariable(itemType);
    asmGenerator.InitializeVariable(vessel);
    asmGenerator.CastVariable(item, vessel);

    asmGenerator.Comment($"{item.Print} -> {vessel.Print}\n");
    return vessel;
  }
\end{lstlisting}

\par Funkcja generująca asemblera do rzutowania zmiennych, początkowo sprawdza, czy dany element jest stałą czy zmienną. W przypadku kiedy podany zostanie element opisujący wartość stałą, generator najpierw utworzy zmienną, a następnie przypisze do niej wartość stałej. Jest to konieczne, ponieważ rzutowanie typów zmiennych nie może odbywać się na wartościach stałych. Następnie w zależności od tego czy będzie odbywać się rzutowanie na wartość rzeczywistą czy łańcuch znaków, zostanie wygenerowany odpowiedni kod.

\begin{lstlisting}[language=IL, caption=Kod assemblera rzutowania wrtości całkowitej na wartość rzeczywistą, label=alg:variable3]
  // załadowanie stałej wartości całkowitej "5"
  ldc.i4 5
  // przypisanie wartości "5" do zmiennej "v_tmp_36"
  stloc v_tmp_36

  // załadowanie wrtości "v_tmp_36"
  ldloc v_tmp_36
  // konwersja wartości do typu rzeczywistego
  conv.r4
  // zapisanie wyniku konwersji do zmiennej "v_tmp_35"
  stloc v_tmp_35
\end{lstlisting}

\par W przypadku rzutowania zmiennych na łańcuch znaków, należy wywołać procedurę konwertującą wartość \texttt{ToString()}. Przy wywołaniu trzeba podać typ źródłowy wartości jaką chcemy rzutować. Są to odpowiednio:
\begin{itemize}
  \item \texttt{Int32} dla typu całkowitego
  \item \texttt{Single} dla typu rzeczywistego
  \item \texttt{Boolean} dla typu logicznego
\end{itemize}

\begin{lstlisting}[language=IL, caption=Kod assemblera rzutowania wrtości rzeczywistej na wartość łańcucha znaków, label=alg:variable4]
  // załadowanie stałej wartości całkowitej "4.7"
  ldc.r4 4.7
  // przypisanie wartości "5" do zmiennej "v_tmp_34"
  stloc v_tmp_34
  // załadowanie adresu "v_tmp_34"
  ldloca.s v_tmp_34
  // wywołanie procedury konwersji typu rzeczywistego na wartość łańcucha znaków
  call instance string [mscorlib]System.Single::ToString()
  // zapisanie wyniku konwersji do zmiennej "v_tmp_33"
  stloc v_tmp_33
\end{lstlisting}

\par Przy generowaniu kodu assemblera dla tej konwersji, w przypadku kiedy znajduje się ona w ciele funkcji, są wstawiane znaczniki. Będą one zamieniane na instrukcje asemblerowe dopiero po przeanalizowaniu całego kodu pliku wejściowego. Taki zabieg wynika z konieczności, podania typu wartości źródłowej przy wywołaniu funkcji \texttt{ToString()}, a przy analizowaniu funkcji dany typ może być nie znany.

\begin{lstlisting}[language=IL, caption={Przykład kodu assemblera rzutowania wrtości w funkcji, przed podmianą znacznika i po podmianie}, label=alg:variable4]
  // Znacznik opisuje, że w funkcji o nazwie "convert" należy obsłużyć rzutowanie zmiennej o nazwie "a"
  ldarga v_a
  #CAST_VARIABLE#a@convert
  stloc v_tmp_3

  // Kod asemblera po zamianie znacznika
  ldarga v_a
  call instance string [mscorlib]System.Single::ToString()
  stloc v_tmp_3
\end{lstlisting}

\subsubsection{Obsługa działań arytmetycznych}

\par Moduł obsługi działań arytmetycznych zawiera definicje elementu znaku działań matematycznych, obsługę funkcjonalności działań matematycznych, operacji przypisania oraz inkrementacji zmiennej.
\par Definiowanie elementu znaku działań matematycznych odbywa się w identyczny sposób jak przy definicji wartości stałych i zmiennych. Na główny stos aplikacji zostaje wrzucony element opisujący działanie, a raczej znak działania matematycznego.
\par Przy definiowaniu gramatyki dla działań matematycznych należy zdefiniować osobne reguły dla działań dodawania i odejmowania oraz mnożenia i dzielenia, w celu zachowania zasady kolejności wykonywania działań.

\begin{lstlisting}[caption=Definicja gramatyki dla funkcji działań matematycznych, label=alg:arytm1]
  arithmeticOperation
  : arithmeticOperation arithmeticAdditiveSign arithmeticOperationHigher
  | arithmeticOperationHigher
  ;

  arithmeticOperationHigher
  : arithmeticOperationHigher arithmeticMultiplpicativeSign value
  | value
  ;

  arithmeticAdditiveSign
  : PLUS
  | MINUS
  ;

  arithmeticMultiplpicativeSign
  : MULTIPLY
  | DIVIDE
  ;
\end{lstlisting}


\par Przy wywołaniu funkcji przetworzenia działania matematycznego, na stosie głównym znajdować się będą trzy elementy uczestniczące w działaniu. Będzie to kolejno dwa elementy opisujące wartości oraz element opisujący znak operacji. Następnie weryfikowane jest jakiego typu są elementy. W przypadku różnych typów danych wykonywane są funkcje rzutowania wartości na wspólne typy danych.

\begin{lstlisting}[language=CSharp, caption=Implementacja funkcji obsługującej działania matematyczne cz.1, label=alg:arytm2]
  public void ProcessArithmeticOperation() {
    StoreItem arg2 = Store.PopStack();
    StoreItem sign = Store.PopStack();
    StoreItem arg1 = Store.PopStack();

    bool stringOperation = false;

    if (StoreItem.IsAnyType(StoreItemType.STRING, arg1, arg2)) {
      if (sign.Value != "+") {
        throw new InvalidOperationException($"Operation is not allowed for strings.");
      }
      stringOperation = true;

      arg1 = variableModule.CastVariable(arg1, StoreItemType.STRING);
      arg2 = variableModule.CastVariable(arg2, StoreItemType.STRING);
    }
    if(sign.Value == "/" || StoreItem.IsAnyType(StoreItemType.DOUBLE, arg1, arg2)){
      arg1 = variableModule.CastVariable(arg1, StoreItemType.DOUBLE);
      arg2 = variableModule.CastVariable(arg2, StoreItemType.DOUBLE);
    }

    ...
\end{lstlisting}

\par Następnie wywoływane są funkcje generujące kod asemblera. W pierwszym kroku obie wartości są ładowane na stos, a następnie w zależności od tego, czy operacja jest wykonywana na typach łańcuchów znaków, czy na wartościach liczbowych, wykonywane są funkcje do łączenia wartości typu łańcuchowego lub też do wykonania operacji na liczbach.

\begin{lstlisting}[language=CSharp, caption=Implementacja funkcji obsługującej działania matematyczne cz.2, label=alg:arytm3]
  ...

  asmGenerator.Load(arg1);
  asmGenerator.Load(arg2);
  if (stringOperation) {
    asmGenerator.ConcatStrings();
  } else {
    asmGenerator.ExecuteArithmeticOperation(sign);
  }

  ...
\end{lstlisting}

\par Na końcu tworzona jest nowa zmienna do której przypisywana będzie wartość wyniku powyższej operacji oraz wynik zostanie wrzucony na główny stos kompilatora. W przypadku kiedy jedna z wartości była już elementem tymczasowym, zamiast tworzenia nowego elementu tymczasowego, wynik zostanie przypisany już do istniejącego.

\begin{lstlisting}[language=CSharp, caption=Implementacja funkcji obsługującej działania matematyczne cz.3, label=alg:arytm4]
  ...

  StoreItem resultItem;
  if (arg1.IsTemporary) {
    resultItem = arg1;
  } else if (arg2.IsTemporary) {
    resultItem = arg2;
  } else {
    resultItem = StoreItem.CreateTemporaryVariable(arg1.ItemType);
    resultItem.Parent = arg1;
    asmGenerator.InitializeVariable(resultItem);
  }

  Store.PushStack(resultItem);
  asmGenerator.StoreVariable(resultItem);
\end{lstlisting}

\par Aby wykonać działanie matematyczne w kodzie asemblerowym, należy jak już wcześniej było opisywane, załadować dwie wartości na stos i wywołać jedną z następujących instrukcji:
\begin{itemize}
  \item \texttt{add} - dodawanie
  \item \texttt{sub} - odejmowanie
  \item \texttt{mul} - mnożenie
  \item \texttt{div} - dzielenie
\end{itemize}
Wynik operacji zostanie zapisany na stosie, który następnie można przypisać do zmiennej.

\begin{lstlisting}[language=IL, caption=Kod assemblera przedstawiający mnożenie dwóch liczb, label=alg:arytm5]
  // załadowanie liczby stałej o wartości 10
  ldc.i4 10
  // załadowanie liczby stałej o wartości 15
  ldc.i4 15
  // wywołanie operacji mnożenia
  mul
  // zapisanie wyniku do zmiennej "v_tmp_1"
  stloc v_tmp_1
\end{lstlisting}
Natomiast dodawanie do siebie dwóch łańcuchów polega na wywołaniu procedury. Tak jak w przypadku operacji matematycznych liczb, należy załadować na stos dwie wartości łańcuchowe a następnie wywołać procedurę \texttt{Concat}.

\begin{lstlisting}[language=IL, caption=Kod assemblera przedstawiający łączenie dwóch tekstów, label=alg:arytm6]
  // Załadowanie ciągu "Hello "
  ldstr "Hello "
  // Załadowanie ciągu "World!"
  ldstr "World!"
  // Wywołanie procedury łączenia ciągów
  call string [mscorlib]System.String::Concat(string,string)
  // Zapisanie wyniku do zmiennej "v_tmp_1"
  stloc v_tmp_1
\end{lstlisting}

\par Kolejną z funkcjonalności w module obsługi działań arytmetycznych jest instrukcja przypisania wartości do zmiennej. W tej operacji bierze udział element źródłowy, z którego pobrana będzie wartość oraz element docelowy, do którego zostanie przypisana wartość.
\par Funkcja realizująca przypisanie wartości, na początku pobiera ze stosu głównego kompilatora element źródłowy i docelowy. Następnie jest sprawdzany element docelowy, czy jest to element opisujący zmienną należącą do tablicy, jeśli tak wywoływana jest funkcja generująca kod asemblerowy dla tego przypadku.

\begin{lstlisting}[language=CSharp, caption=Implementacja funkcji obsługującej przypisanie wartości cz.1, label=alg:assign1]
  public void Assign(){
    StoreItem source = Store.PopStack();
    StoreItem dist = Store.PopStack();
    if(dist.IsType(StoreItemType.ARRAY_ELEMENT)){
      assignArrayElement(source, dist);
      return;
    }
    asmGenerator.Load(source);
    asmGenerator.RemoveLastDuplicate();

    ...
\end{lstlisting}

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji pomocniczej, obsługującej przypisanie wartości do elementu tablicowego}, label=alg:assign2]
  private void assignArrayElement(StoreItem source, StoreItem dist) {
    asmGenerator.LoadVariableWithoutCheck(dist);
    asmGenerator.Load(dist.TableIndex);
    asmGenerator.Load(source);
    asmGenerator.SetElementForList();
    asmGenerator.Comment($"{dist.Print} = {source.Print}\n");
  }
\end{lstlisting}

\par Spowodowane jest to tym, że przypisywanie wartości dla tablic, wymaga podania zmiennej przechowującej adres tablicy, następnie indeksu elementu, a na końcu wartości przypisywanej. Następnie można wykonać procedurę przypisania wartości \texttt{set\_Item}.

\begin{lstlisting}[language=IL, caption=Kod assemblera przedstawiający przypisanie wartości do elementu tablicowego, label=alg:assign3]
  // Załadowanie zmiennej przechowującej tablicę
  ldloc v_myArray
  // Załadowanie zmiennej przechowującej indeks elementu tablicy
  ldloc v_tmp_2
  // Załadowanie wartości 100
  ldc.i4 100
  // Wywołanie procedury przypisania
  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<int32>::set_Item(int32, !0)
\end{lstlisting}

\par W przypadku przypisania wartości dla zwykłej zmiennej, wystarczy załadować na stos element źródłowy, a następnie załadować ze stosu wartość do elementu docelowego. W funkcji obsługującej przypisanie wartości, sprawdzane są dodatkowo informacje odnośnie typów wartości, jak i dopisanie elementów do listy wykorzystywanych zmiennych.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługującej przypisanie wartości cz.2}, label=alg:assign4]
  ...

  if (!dist.IsInitialized) {
      StoreItemType distOrginalType = dist.ItemType;
      if(source.IsType(StoreItemType.ARRAY_ELEMENT)){
        dist.ItemType = StoreItemType.INTEGER;
      } else {
        dist.ItemType = source.ItemType;
      }
      if(distOrginalType == StoreItemType.UNDEFINED){
        asmGenerator.InitializeVariableFromUndefined(dist);
      } else {
        asmGenerator.InitializeVariable(dist);
      }
    }
    dist.Parent = source.Parent;
    asmGenerator.StoreVariable(dist);
    asmGenerator.Comment($"{dist.Print} = {source.Print}\n");
  }
\end{lstlisting}

\begin{lstlisting}[language=IL, caption=Kod assemblera przedstawiający przypisanie wartości, label=alg:assign5]
  // Załadowanie na stos wartości zmiennej "v_tmp_1"
  ldloc v_tmp_1
  // Przypisanie wartości ze stosu zmiennej "v_tmp_2"
  stloc v_tmp_2
\end{lstlisting}

\par Ostatnim z funkcjonalności implementowanych przez moduł obsługi działań arytmetycznych jest inkrementacja wartości zmiennej. Można to zrealizować poprzez dodanie stałej wartości ``1'' dla podanego elementu.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługującej inkrementację wartości}, label=alg:assign6]
  public void IncrementVariable() {
    StoreItem item = Store.PopStack();
    StoreItem one = StoreItem.CreateInteger("1");
    asmGenerator.Load(item);
    asmGenerator.Load(one);
    StoreItem addSign = StoreItem.CreateArithmeticSign("+");
    asmGenerator.ExecuteArithmeticOperation(addSign);
    asmGenerator.StoreVariable(item);
    asmGenerator.Comment($"{item.Print}++");
  }
\end{lstlisting}
Generowany kod asemblera jest identyczny jak przy zwykłej operacji wykonywania działania matematycznego.

\begin{lstlisting}[language=IL, caption=Kod assemblera przedstawiający inkrementacje wartości, label=alg:assign7]
  // Załadowanie na stos wartości zmiennej "v_i"
  ldloc v_i
  // Załadowanie na stos stałej wartości "1"
  ldc.i4 1
  // wywołanie operacji dodawania
  add
  // Zapisanie wyniku do zmiennej "v_i"
  stloc v_i
\end{lstlisting}


\subsubsection{Obsługa wyrażeń warunkowych}

Moduł obsługi wyrażeń warunkowych odpowiedzialny jest za przetworzenie instrukcji porównania, instrukcję negacji oraz obsługi instrukcji warunkowej. Instrukcja porównania jest bardzo podobna instrukcji działania matematycznego. Uczestniczą w niej dwa elementy reprezentujące wartości oraz jeden element odpowiedzialny za operację porównania.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługującej wyrażenia warunkowe cz.1}, label=alg:condition1]
  public void ProcessCondition() {
    StoreItem arg2 = Store.PopStack();
    StoreItem sign = Store.PopStack();
    StoreItem arg1 = Store.PopStack();

    bool stringOperation = false;
    if (StoreItem.IsAnyType(StoreItemType.STRING, arg1, arg2)) {
      if (!Array.Exists(new[] {"==", "===", "!=", "!=="}, x => x == sign.Value) ) {
        throw new InvalidOperationException($"Operation is not allowed for strings.");
      }
      stringOperation = true;

      arg1 = variableModule.CastVariable(arg1, StoreItemType.STRING);
      arg2 = variableModule.CastVariable(arg2, StoreItemType.STRING);
    }

    ...
\end{lstlisting}

\par Wynik operacji, tak ja to było przy działaniach matematycznych, zapisywany jest do zmiennej tymczasowej i jeśli jeden z elementów już był zmienną tymczasową, zamiast tworzyć nowy element, zostanie ponownie wykorzystany już istniejący.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługującej wyrażenia warunkowe cz.2}, label=alg:condition4]
    ...

    asmGenerator.Load(arg1);
    asmGenerator.Load(arg2);

    if (stringOperation) {
      asmGenerator.CompareStrings(sign);
    } else {
      asmGenerator.ExecuteConditionOperation(sign);
    }

    StoreItem resultItem;
    if (arg1.IsTemporary && arg1.IsType(StoreItemType.BOOLEAN)) {
      resultItem = arg1;
    } else if (arg2.IsTemporary && arg2.IsType(StoreItemType.BOOLEAN)) {
      resultItem = arg2;
    } else {
      resultItem = StoreItem.CreateTemporaryVariable(StoreItemType.BOOLEAN);
      asmGenerator.InitializeVariable(resultItem);
    }
    Store.PushStack(resultItem);
    asmGenerator.StoreVariable(resultItem);

    ...
  }
\end{lstlisting}

\par Przy operacjach na łańcuchach znaków jest również wykonywane rzutowanie zmiennych na ciąg łańcuchowy, ponieważ dla tego typu danych należy wywołać procedury \texttt{op\_Equality} lub \texttt{op\_Inequality}, które pozwalają na sprawdzenie równości lub nierówności dwóch ciągów.

\begin{lstlisting}[language=IL, caption={Kod assemblera przedstawiający porównanie dwóch łańcuchów zanków}, label=alg:condition2]
  // Załadowanie na stos wartości zmiennej "v_tmp_1"
  ldloc v_tmp_1
  // Załadowanie na stos stałej wartości wartości "text"
  ldstr "text"
  // Wywołanie procedury "op_Equality" sprawdzającą równośc
  call bool [mscorlib]System.String::op_Equality(string,string)
  // Zapisanie wyniku do zmiennej "v_tmp_2"
  stloc v_tmp_2
\end{lstlisting}

\par Dla porównania wartości liczbowych wykorzystywane są proste instrukcje asemblerowe:
\begin{itemize}
  \item \texttt{cgt} - większy od
  \item \texttt{clt} - mniejszy od
  \item \texttt{ceq} - równy
\end{itemize}
Dla operacji takich jak: większy równy, mniejszy równy lub nierówny, nie ma odpowiednich dla nich instrukcji w asemblerze. Aby móc je wykonać, należy w kodzie assemblera porównać wynik wywołania powyżej wypisanych instytucji z wartością zerową. Przykładowo, jeśli chcemy wykonać porównanie ``większy lub równy'', należy wykonać operację ``mniejszy'' (\texttt{clt}) a następnie wynik porównać z wartością zerową.

\begin{lstlisting}[language=IL, caption={Kod assemblera przedstawiający porównanie ``mnieszy lub równy''}, label=alg:condition3]
  // Załadowanie na stos stałej wartości "5"
  ldc.i4 5
  // Załadowanie na stos wartości zmiennej "v_v1"
  ldloc v_v1
  // Wywołanie operacji porwónania "większy od"
  cgt
  // Załadowanie na stos stałej wartości "0"
  ldc.i4.0
  // Wywołanie operacji porwónania "równy"
  ceq
  // Zapisanie wyniku do zmiennej "v_tmp_1"
  stloc v_tmp_1
\end{lstlisting}

\par Następnym z elementów modułu jest implementacja funkcji dla instrukcji negacji. Funkcja pobiera ze stosu element, generuje dla niego kod asemblerowy i wynik zapisuje w zmiennej tymczasowej, która z powrotem jest wrzucana na stos.


\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługującej negację wartości}, label=alg:condition5]
  public void NotStatement() {
    StoreItem item = Store.PopStack();
    asmGenerator.Load(item);
    asmGenerator.Negation();
    StoreItem resultItem = StoreItem.CreateTemporaryVariable(StoreItemType.BOOLEAN);
    asmGenerator.InitializeVariable(resultItem);
    asmGenerator.StoreVariable(resultItem);
    Store.PushStack(resultItem);
    asmGenerator.Comment($"{resultItem.Print} = !{item.Print}");
  }
}
\end{lstlisting}

\par W kodzie asemblerowym, negacja wartości polega na jej przyrównaniu do stałej wartości zerowej. Dzięki takiemu zabiegowi, w przypadku kiedy mamy wartość ``true'' i porównamy ją do wartości zerowej ``false'' to otrzymamy jako wynik wartość ``false''. W przypadku kiedy jest to wartość ``false'' to wynikiem będzie wartość ``true''.

\begin{lstlisting}[language=IL, caption={Kod assemblera przedstawiający porównanie ``mnieszy lub równy''}, label=alg:condition6]
  // Załadowanie na stos wartości zmiennej "v_t1"
  ldloc v_t1
  // Załadowanie na stos stałej wartości "0"
  ldc.i4.0
  // Porównanie wartości
  ceq
  // Zapisanie wyniku do zmiennej "v_t2"
  stloc v_t2
\end{lstlisting}

\par W module obsługi wyrażeń warunkowych, nie może zabraknąć funkcji obsługujących wyrażenie warunkowe \texttt{if}. Dla tej instrukcji zostały zdefiniowane trzy reguły: dla konstrukcji wyrażenia, operacji porównania oraz instrukcji \texttt{else}.

\begin{lstlisting}[language=IL, caption={Gramatyka dla instrukcji \texttt{if}}, label=alg:if1]
  ifStatement
    : IF '(' ifStatementConditionOperation ')' instructionBlock elseStatement?
    ;

  ifStatementConditionOperation
    : conditionOperation
    ;

  elseStatement
    : ELSE instructionBlock
    ;
\end{lstlisting}

\par Instrukcje warunkowe opierają się głównie o etykiety oraz skoki warunkowe. W tym celu w klasie \texttt{Store} stworzony jest oddzielny stos oraz licznik indexów dla operacji wykorzystujące etykiety. 

\par Pierwszą z funkcji wywoływanych przy przetwarzaniu instrukcji \texttt{if}, jest funkcja wywoływana na rozpoczęcie przetwarzania reguły \texttt{ifStatement}. Ma ona za zadanie utworzyć index instrukcji i umieścić go na stosie indeksów. Funkcja nie generuje kodu asemblera.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji wywoływanej przy rozpoczęciu analizy instrukcji \texttt{if}}, label=alg:if2]
  public void BeginIfStatement(){
    int ifIndex = Store.NextLabelIndex();
    Store.PushLabelStack(ifIndex);
  }
}
\end{lstlisting}

\par Drugą z kolei jest wywoływana funkcja, która ma za zadanie wygenerować kod asemblera sprawdzający warunek instrukcji \texttt{if}. Pobierany jest element z głównego stosu, a następnie wywoływana jest instrukcja skoku warunkowego. Skok ten wykonywany jest do wskazanej etykiety, tylko w przypadku kiedy wartość elementu jest fałszywa. Etykieta generowana jest na podstawie wartości znajdującej się na stosie indeksów.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługująca warunek instrukcji \texttt{if}}, label=alg:if3]
  public void IfStatementCondition() {
    StoreItem item = Store.PopStack();
    asmGenerator.Load(item);

    int ifIndex = Store.TopLabelStack();
    asmGenerator.JumpIfFalse($"IF_{ifIndex}");

    asmGenerator.Comment($"if ({item.Print} == false) JUMP IF_{ifIndex}");
  }
}
\end{lstlisting}

\par Następną z funkcji jest obsługa instrukcji \texttt{else}. Jej celem jest utworzenie etykiety w kodzie asemblera dla wcześniej utworzonego skoku, oraz utworzenie kolejnej instrukcji skoku dla sekcji instrukcji \texttt{else} przy pomocy nowego indeksu. 

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługująca sekcje \texttt{else} instrukcji \texttt{if}}, label=alg:if4]
  public void ElseStatement() {
    int elseIndex = Store.NextLabelIndex();
    int ifIndex = Store.PopLabelStack();
    asmGenerator.Jump($"IF_{elseIndex}");
    asmGenerator.CreateLabel($"IF_{ifIndex}");
    Store.PushLabelStack(elseIndex);

    asmGenerator.Comment($"ELSE");
  }
\end{lstlisting}

\par Ostatnią z funkcji jest obsługa zakończenia przetwarzania instrukcji \texttt{if}. Służy jedynie do utworzenia etykiety kończącej konstrukcję.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji wywoływanej przy zakończeniu analizy instrukcji \texttt{if}}, label=alg:if5]
  public void EndIfStatement() {
    int ifIndex = Store.PopLabelStack();
    asmGenerator.CreateLabel($"IF_{ifIndex}");
  }
\end{lstlisting}

\begin{lstlisting}[language=IL, caption={Kod assemblera przedstawiający konstrukcję \texttt{if ... else}}, label=alg:if6]
  // Załadowanie na stos wartości zmiennej "v_tmp_0"
  ldloc v_tmp_0
  // Instrukcja skoku. Jeśli "v_tmp_0" jest wartością "false" zostatnie wykonany skok do etykeyty "IF_0"
  brfalse IF_0

  // Instrukcje bloku warunkowego "if"
  ...

  // Skok bezwarunkowy do etytkiety "IF_1"
  br IF_1
  // Deklaracja etytkiety "IF_0"
  IF_0: 

  // Instrukcje bloku warunkowego "else"
  ...

  // Deklaracja etytkiety "IF_1"
  IF_1: 
\end{lstlisting}


\subsubsection{Obsługa pętli}

Moduł obsługi pętli zawiera szereg funkcji obsługujących instrukcje \texttt{for} oraz \texttt{while}. Definicja reguł gramatyki dla instrukcji \texttt{while} zawarta jest jedynie w dwóch regułach. Pierwsza jest ogólną konstrukcją instrukcji, a druga służy do obsłużenia warunku pętli.

\begin{lstlisting}[language=IL, caption={Gramatyka dla instrukcji \texttt{while}}, label=alg:while1]
whileLoop
  : WHILE '(' whileStatementConditionOperation ')' instructionBlock
  ;

whileStatementConditionOperation
  : conditionOperation
  ;
\end{lstlisting}

\par Dla powyższej gramatyki wykorzystywane są trzy funkcji parsera. Pierwszą z nich jest funkcja wywoływana przed analizą reguły. Jej zadaniem jest utworzenie etykiety początku pętli.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługująca rozpoczęcie analizy instrukcji \texttt{while}}, label=alg:while2]
  public void BeginWhile() {
    int labelIndex = Store.NextLabelIndex();
    Store.PushLabelStack(labelIndex);
    asmGenerator.CreateLabel($"WL_{labelIndex}");
  }
\end{lstlisting}

\par Kolejną z wywoływanych funkcji jest obsługa wyrażenia warunkowego. Pobierana jest ze stosu kompilatora element wyniku wyrażenia warunkowego, a następnie generowany jest dla niego skok warunkowy do etykiety kończącej instrukcję \texttt{while}.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługująca wyrażenie warunkowe instrukcji \texttt{while}}, label=alg:while3]
  public void CheckWhileCondition() {
    StoreItem item = Store.PopStack();
    asmGenerator.Load(item);
    int labelIndex = Store.TopLabelStack();
    asmGenerator.JumpIfFalse($"WL_EXIT_{labelIndex}");
  }
\end{lstlisting}

\par Ostatnią z funkcji przeznaczonych dla instrukcji \texttt{while} w tym module, jest funkcja wywoływana na zakończenie analizy reguły. Generuje ona skok bezwarunkowy do etykiety na początku pętli, oraz tworzy etykietę kończącą pętlę \texttt{while}.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługująca kończącej analize instrukcji \texttt{while}}, label=alg:while4]
  public void EndWhile() {
    int labelIndex = Store.PopLabelStack();
    asmGenerator.Jump($"WL_{labelIndex}");
    asmGenerator.CreateLabel($"WL_EXIT_{labelIndex}");
  }
\end{lstlisting}

\begin{lstlisting}[language=IL, caption={Kod assemblera przedstawiający konstrukcję \texttt{while}}, label=alg:while5]
  // Utworzenie etykiety początku pętli 
  WL_0: 
  
  // Instrukcja warunkowa "x < 10"
  ldloc v_x
  ldc.i4 10
  clt
  stloc v_tmp_0
  
  // Sprawdzenie warunku i wykonanie skoku do etykiety końca pętli
  ldloc v_tmp_0
  brfalse WL_EXIT_0
  
  // Blok instukcji
  ...

  // Skok bezwarunkowy do etykiety początku pętli 
  br WL_0
  // Utworzenie etykiety końca pętli 
  WL_EXIT_0: 
\end{lstlisting}

\par Definicja reguł gramatyki dla instrukcji \texttt{for} jest bardziej złożona. Dla tej instrukcji, poza sprawdzeniem wyrażenia warunkowego, występuje również inicjalizacja wartości zmiennych oraz wyrażenie inkrementacji wartości.

\begin{lstlisting}[language=IL, caption={Gramatyka dla instrukcji \texttt{while}}, label=alg:for1]
forLoop
  : FOR '(' forAssignSection? ';' forStatementConditionOperation ';' forExpression? ')' instructionBlock
  ;

forAssignSection
  : assignOperation (COMMA+ assignOperation)*
  ;

forStatementConditionOperation
  : conditionOperation
  ;

forExpression
  : forExpressionAssign
  | incrementVariable
  ;

forExpressionAssign
  : identifierValue ASSIGN assignValue
  ;
\end{lstlisting}

\par Funkcje rozpoczynająca oraz zakańczająca analizę instrukcji \texttt{for} jest taka sama. Różnią się jedynie nazwą generowanych etykiet. Funkcja sprawdzająca warunek, też jest bardzo podobna. Posiada jedynie dodatkowo skok bezwarunkowy pomijający kod wyrażenia inkrementacji.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługująca wyrażenie inkrementacji}, label=alg:for2]
  public void BeginForExpression() {
    int labelIndex = Store.TopLabelStack();
    asmGenerator.CreateLabel($"FL_EX_{labelIndex}");
  }

  public void EndForExpression () {
    int labelIndex = Store.TopLabelStack();
    asmGenerator.Jump($"FL_{labelIndex}");
    asmGenerator.CreateLabel($"FL_BODY_{labelIndex}");
  }
\end{lstlisting}

\par Funkcje obsługujące wyrażenie inkrementacji tworzą jedynie etykiety oraz skok bezwarunkowy do początku pętli. Wyrażenie inicjalizacji jest przetwarzane przed rozpoczęciem generowania kodu dla pętli.

\begin{lstlisting}[language=IL, caption={Kod assemblera przedstawiający konstrukcję \texttt{while}}, label=alg:while5]
  // Inicjalizacja wartości zmiennej "index"
  ldc.i4 0
  stloc v_index

  // Utworzenie etykiety początku pętli 
  FL_0: 
  
  // Instrukcja warunkowa "index < 10"
  ldloc v_index
  ldc.i4 10
  clt
  stloc v_tmp_0

  // Sprawdzenie warunku i wykonanie skoku do etykiety końca pętli
  ldloc v_tmp_0
  brfalse FL_EXIT_0
  br FL_BODY_0
  
  // Utworzenie etykiety początku wyrażenia inkrementacji
  FL_EX_0: 

  // Instrukcje inkrementacji
  ...
  
  // Skok bezwarunkowy do poczatku pętli
  br FL_0
  // Utworzenie etykiety początku ciała pętli
  FL_BODY_0: 

  // Blok instukcji
  ...
  
  // Skok bezwarunkowy do wyrażenia inkrementacji
  br FL_EX_0
  // Utworzenie etykiety końca pętli
  FL_EXIT_0: 
\end{lstlisting}

\subsubsection{Obsługa tablic}
Moduł obsługi tablic zawiera implementacje funkcji obsługujących deklarowanie tablic, tworzenie elementów tablicowych, dodawanie elementów do tablicy oraz obsługa funkcji pobierającą ilość elementów znajdujących się w podanej tablicy.
\par Funkcjonalność tablic została uproszczona do przechowywania jedynie elementów liczb całkowitych. Realizowane jest to przy wykorzystaniu generycznej klasy \texttt{List} typu \texttt{int} wbudowanej biblioteki środowiska .NET.
\par Dla deklaracji tablicy elementów zostały wykorzystane trzy reguły pozwalające na zdeklarowanie tablicy o dowolnej ilości elementów przy pomocy nawiasów kwadratowych.

\begin{lstlisting}[caption=Definicja gramatyki dla deklaracji tablicy z wartościami, label=alg:array1]
arrayLiteral
  : (OPEN_BRACKET elementList CLOSE_BRACKET)
  ;

elementList
  : COMMA* arrayElement? (COMMA+ arrayElement)* COMMA*
  ;

arrayElement
  : singleExpression
  ;
\end{lstlisting}

\par Funkcja obsługująca deklaracje tablic tworzy zmienną tymczasową dla której tworzona jest instancja listy elementów. Następnie element opisujący zmienną jest wrzucany na główny stos. Kolejnym krokiem przy deklaracji tablic jest dodanie elementów do tablicy. Dla każdej z liczb podanych w nawiasach kwadratowych w kodzie źródłowym, generowany jest kod wywołujący funkcję \texttt{Add}.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługujących deklaracje tablicy}, label=alg:array2]
  public void CreateTempArray() {
    StoreItem array = StoreItem.CreateTemporaryVariable(StoreItemType.ARRAY);
    asmGenerator.CtorVariable(array);
    asmGenerator.Comment($"CREATE ARRAY {array.Value}");
    Store.PushStack(array);
  }
  
  public void AddElementToArray() {
    StoreItem item = Store.PopStack();
    StoreItem array = Store.TopStack();
    asmGenerator.Load(item);
    asmGenerator.AddElementToList(array);
  }
\end{lstlisting}

\begin{lstlisting}[language=IL, caption={Kod assemblera przedstawiający deklarację tablicy}, label=alg:array3]
  // Utworzenie nowej istancji klasy "List" typu "int32"
  newobj instance void class [mscorlib]System.Collections.Generic.List`1<int32>::.ctor()
  stloc v_tmp_0
  ldloc v_tmp_0

  // Załadowanie na stos liczby "10"
  ldc.i4 10
  // Dodanie liczby do listy
  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<int32>::Add(!0)
  ldloc v_tmp_0
\end{lstlisting}

\par Kolejną z funkcji w module obsługującym tablice, jest funkcja obsługująca tworzenie zmiennych będących elementami tablicy. Funkcja ta nie generuje kodu asemblerowego, a jedynie tworzy element, który będzie obsługiwany w innych modułach.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługująca wystąpienie elementu tablicowego}, label=alg:array4]
  public void CreateTableVariable(string value) {
    StoreItem index = Store.PopStack();
    variableModule.CreateVariable(value);
    StoreItem array = Store.PopStack().Clone();
    array.TableIndex= index;
    array.ItemType = StoreItemType.ARRAY_ELEMENT;
    asmGenerator.Comment($"{array.Value}[{index.Value}]");
    Store.PushStack(array);
  }
\end{lstlisting}

\par Ostania z funkcji w tym module jest obsługa instrukcji pobrania ilości elementów tablicy. Początkowo jest tworzona zmienna tymczasowa która ma przechować wynik operacji. Następnie generowany jest kod asemblera, który pobiera długość listy przy pomocy funkcji \texttt{get\_Count}, a następnie zapisuje wartość we wcześniej utworzonej zmiennej. Wynik jest wrzucany na stos główny aplikacji.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługująca pobieranie ilości elementów tablicy}, label=alg:array5]
  public void GetArrayLength(string arrayName) {
    StoreItem array = Store.GetVariableIfExist(arrayName);
    if(!array.IsInitialized){
      throw new InvalidOperationException($"Variable {array.Print} is undfined");
    }
    if(array.IsNotType(StoreItemType.ARRAY, StoreItemType.FUNCTION_ARG)){
      throw new InvalidOperationException($"Variable {array.Print} must be an array");
    }
    StoreItem arrLen = StoreItem.CreateTemporaryVariable(StoreItemType.INTEGER);
    asmGenerator.InitializeVariable(arrLen);
    asmGenerator.Load(array);
    asmGenerator.GetListSize();
    asmGenerator.StoreVariable(arrLen);
    asmGenerator.Comment($"{arrLen.Print} = {array.Print}:LENGTH");
    Store.PushStack(arrLen);
  }
\end{lstlisting}

\begin{lstlisting}[language=IL, caption={Kod assemblera przedstawiający pobieranie ilości elementów tablicy}, label=alg:array6]
  // Załadowanie zmiennej tablicowej
  ldloc v_myArray
  // Pobranie ilości elementów tablicy
  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<int32>::get_Count()
  // Zapisanie wyniku do zmiennej tymczasowej
  stloc v_tmp_1
\end{lstlisting}

\subsubsection{Obsługa funkcji}

\par Ostatnim z modułów odpowiedzialny jest za obsługę funkcji. Zawiera obsługę deklaracji funkcji, interpretowanie parametrów funkcji, wywoływanie oraz obsługę wartości zwracanej z funkcji. Deklaracja funkcji jest polega na utworzeniu osobnej listy instrukcji w generatorze asemblera. Dodatkowo klasa \texttt{Store} jest przestawiany na kontekst obsługi instrukcji wewnątrz funkcji. Kontekst jest przywracany po zakończeniu obsługi instrukcji wewnątrz funkcji.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji do deklaracji funkcji}, label=alg:f1]
  public void BeginFunctionDeclaration(string functionName){
    asmGenerator.Comment($"FUNCTION {functionName}");
    asmGenerator.EmptyLine();
    asmGenerator.CreateFunction(functionName);
  }
  
  public void EndFunctionDeclaration(string functionName) {
    asmGenerator.EndFunction();
  }
\end{lstlisting}

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji w klasie \texttt{Store} do deklaracji funkcji}, label=alg:f1]
  public void CreateFunction(string name) {
    FunctionAsmLines functionAsmLines = new FunctionAsmLines(name);
    if(asmFunctionsLines.ContainsKey(name)){
      throw new ArgumentException($"Function `{name}` already exist.");
    }
    asmFunctionsLines.Add(name, functionAsmLines);
    Store.SetFunction(name);
  }
\end{lstlisting}

\par Po deklaracji funkcji następuje interpretacja parametrów tej funkcji. Dla każdego z parametrów tworzony jest element opisujący dany parametr. Parametry mają przydzielany specjalny typ \texttt{StoreItemType.FUNCTION\_ARG}, dzięki któremu podczas generowania kodu asemblera bloku instrukcji funkcji, będzie można zostawić znaczniki które zostaną podmienione w postprocesingu. Jest to konieczne, ponieważ typy parametrów, podczas analizy bloku instrukcji funkcji nie są znane do momentu wywołania danej funkcji.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługującej parametry deklarowanej funkcji}, label=alg:f1]
  public void AddParameter(string name){
    StoreItem param = StoreItem.CreateVariable(name);
    param.IsFunctionParam = true;
    param.IsInitialized = true;
    param.ItemType = StoreItemType.FUNCTION_ARG;
    Store.AddVariable(param);
  }
\end{lstlisting}

\par Kolejną z funkcji w tym module jest funkcja odpowiedzialna za obsługę wywołania instrukcji \texttt{return}. Funkcja pobiera element ze stosu głównego, a następnie zapisuje informacje dla danej funkcji, że ten element jest wartością zwracaną funkcji. Generowany kod to jedynie instrukcja załadowania zmiennej na stos oraz instrukcja powrotu.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługującej wywołanie \texttt{return}}, label=alg:f1]
  public void ProcessReturn() {
    StoreItem item = Store.PopStack();
    Store.SetFunctionReturnValue(item);
    asmGenerator.Load(item);
    asmGenerator.Return();
  }
\end{lstlisting}

\begin{lstlisting}[language=IL, caption={Kod assemblera przedstawiający zwracanie elementu}, label=alg:f1]
  // Załadowanie zmiennej "v_returnValue"
  ldloc v_returnValue
  // Wywołanie instrukcji powrotu
  ret
\end{lstlisting}

\par Ostatnią z obsługiwanych funkcjonalności w module jest obsługa wywoływania wcześniej deklarowanych funkcji. Gramatyka zawiera jedynie trzy reguły, które kolejno definiują wywołanie funkcji, listę argumentów funkcji oraz pojedynczy argument. Przy analizie argumentów funkcji, wywoływane są metody do wyzerowania licznika argumentów, a następnie zliczana jest ilość podanych argumentów. Dzięki temu można określić ile należy pobrać elementów ze stosu aplikacji.


\begin{lstlisting}[caption=Definicja gramatyki dla wywołania funkcji z arguemntami, label=alg:gramar]
functionCall
  : IDENTIFIER arguments
  ;

arguments
  : '('(argument (',' argument)* ','?)?')'
  ;

argument
  : assignValue
  ;
\end{lstlisting}


\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji w klasie \texttt{Store} do zliczania argumentów funkcji}, label=alg:cs]
  public static void FunctionCallInitialize() {
    FunctionCallArgCounterStack.Push(0);
  }
  
  public static void FunctionCallArgumentIncrement(){
    int value = FunctionCallArgCounterStack.Pop();
    FunctionCallArgCounterStack.Push(value+1);
  }
\end{lstlisting}

\par Po zakończeniu analizy argumentów wywoływana jest metoda do analizy i wygenerowania kodu asemblerowego dla wywołania podanej funkcji. Na początku są pobierane ze stosu głównego wszystkie argumenty podane przy wywołaniu funkcji i zapisywane do stosu tymczasowego, w celu odwrócenia kolejności argumentów. 

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługującej wywołanie funkcji cz.1}, label=alg:cs]
  public void CallFunction(string name){
    int argCount = Store.FunctionCallArgumentPop();
    Stack<StoreItem> tmpStack = new Stack<StoreItem>();
    List<StoreItem> args = new List<StoreItem>();
    for(int i = 0; i< argCount; i++){
      tmpStack.Push(Store.PopStack());
    }

    ...
\end{lstlisting}

\par Następnie dla każdego z argumentów jest generowany kod asemblera ładujący je do stosu aplikacji. Dodatkowo zapisywana jest informacja w klasie \texttt{Store} o pozycji danego argumentu. Następnie generowany jest kod wywołania danej funkcji z wykorzystaniem listy argumentów. Przy wywoływaniu funkcji wymagane jest podanie typów podanych argumentów.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługującej wywołanie funkcji cz.2}, label=alg:cs]
  ...

  for(int i = 0; i< argCount; i++){
    StoreItem elem = tmpStack.Pop();
    args.Add(elem);
    Store.SetFunctionParamType(name, elem, i);
    asmGenerator.Load(elem);
  }
  asmGenerator.Comment($"FUNC CALL {name}");
  asmGenerator.CallFunction(name, args);

  ...
\end{lstlisting}

\par Ostatnią z części funkcji obsługującej wywołanie funkcji, jest obsługa wartości zwracanej z tej funkcji. W przypadku kiedy funkcja zwraca jakąś wartość, to tworzona jest zmienna tymczasowa, która przechowa wynik wywołania funkcji. Zmienna jest inicjalizowana oraz wrzucana na główny stos aplikacji.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji obsługującej wywołanie funkcji cz.3}, label=alg:cs]
  ...

  FunctionStore functionStore = Store.Functions[name];
  functionStore.IsUsed = true;
  if(!functionStore.IsReturnVoid) {
    StoreItem rootItem = functionStore.ReturnValue.RootItem;
    if(null == rootItem){
      rootItem = functionStore.ReturnValue;
    }
    StoreItem retItem = StoreItem.CreateTemporaryVariable(rootItem.ItemType);
    retItem.Parent = functionStore.ReturnValue;
    asmGenerator.InitializeVariable(retItem);
    asmGenerator.StoreVariable(retItem);
    Store.PushStack(retItem);
  }
}
\end{lstlisting}

\begin{lstlisting}[language=IL, caption={Kod assemblera przedstawiający wywołanie funkcji}, label=alg:f1]
  // Załadowanie stałej "4.7"
  ldc.r4 4.7
  // Wywołanie funkcji "f_convert" z jednym argumentem typu "float32"
  call string Program.Program::f_convert(float32)
  // Zapisanie wartości zwracanej do zmiennej "v_tmp_1"
  stloc v_tmp_1
\end{lstlisting}

\subsection{Generator asemblera}

\par Klasą odpowiedzialną za generowanie assemblera jest klasa \texttt{AsmGenerator}, która wykorzystywana jest w każdym z modułów przetwarzających kod źródłowy. Instancja generatora jest tworzona przy starcie aplikacji kompilatora, następnie przez całe działanie kompilatora zbiera generowane linie kodu asemblera, a po zakończeniu przetwarzania pliku źródłowego, tworzony jest plik wynikowy. Generator posiada następujące elementy:
\begin{itemize}
  \item \texttt{fileName} - nazwę pliku źródłowego
  \item \texttt{tabSize} - wielkość wcięcia kodu
  \item \texttt{asmLines} - lista instrukcji funkcji głównej
  \item \texttt{asmFunctionsLines} - słownik z listą instrukcji deklarowanych funkcji
\end{itemize}

\par Generowany kod asemblerowy dla instrukcji wywoływanych bez deklaracji funkcji zapisywany jest do listy \texttt{asmLines}. Dla instrukcji wywoływanych wewnątrz deklarowanych funkcji, zapisywany jest razem z nazwą funkcji w słowniku \texttt{asmFunctionsLines}. Dzięki temu będzie można w prostszy sposób wygenerować osobny kod dla każdej z funkcji.
\par Generowanie pliku wynikowego zaczyna się od jego utworzenia pod tą samą nazwą co plik źródłowy. Następnie generowany jest nagłówek pliku oraz deklaracja funkcji głównej aplikacji. Dla funkcji głównej tworzone są wszystkie zmienne wykorzystywane w instrukcjach, a następnie przepisywana jest zawartość listy \texttt{asmLines}. Po przepisaniu wszystkich instrukcji funkcja główna jest zamykana. Na końcu tworzone są zdeklarowane funkcje.

\begin{lstlisting}[language=CSharp, caption={Implementacja funkcji generująca plik wynikowy}, label=alg:cs]
private void createAsmFile() {
  StreamWriter outFile = new StreamWriter(Path.Combine(DIST_DIR, $"{this.fileName}.il"));
  this.writeFileHeader(outFile);
  this.initializeAllVariables(outFile, Store.Variables);
  foreach(string line in this.asmLines){
    outFile.WriteLine(line);
  }
  this.writeMainFunctionFooter(outFile);
  this.createAsmFunctions(outFile);
  this.writeFileFooter(outFile);
  outFile.Dispose();
}
\end{lstlisting}

% https://www.codeproject.com/Articles/3778/Introduction-to-IL-Assembly-Language
\par W nagłówku przy pomocy instrukcji \texttt{.assembly} importowana jest standardowa biblioteka \texttt{mscorlib} zawierająca wszystkie podstawowe funkcjonalności platformy .NET. Tą samą instrukcją definiowana jest nazwa asemblerowa pliku oraz w klamrach podawane są dodatkowe informacje o pliku wynikowym. Kolejną z instrukcji nagłówka jest \texttt{.module} która mówi jak nazywać się będzie moduł wynikowy.

\begin{lstlisting}[language=IL, caption={Kod nagłówka pliku wygenerowanego pliku asemblera}, label=alg:asm]
  .assembly extern mscorlib {}
  .assembly Program {}
  .module Program.exe
\end{lstlisting}

\par Następnie generowana jest klasa główna programu przy pomocy instrukcji \texttt{.class} oraz zawarta w niej funkcja główna \texttt{Main}. Funkcja główna deklarowana jest instrukcją \texttt{.method} jako funkcja statyczna nie zwracająca żadnych wartości. Funkcja przyjmuje jako parametr listę elementów typu \texttt{string}, która jest argumentami przyjmowanymi przy uruchomieniu aplikacji. Na końcu deklaracji znajduje się jeszcze słowa kluczowe \texttt{cil managed}, które oznaczają, że dana funkcja zawiera kod zarządzalny. Wewnątrz funkcji głównej znajduje się również instrukcja \texttt{.entrypoint}, która wskazuje miejsce z którego ma rozpocząć się wykonywanie kodu po uruchomieniu aplikacji.

\begin{lstlisting}[language=IL, caption={Kod deklaracji funkcji głównej}, label=alg:asm]
  .class Program.Program
  extends [mscorlib]System.Object
  {
   .method static void Main(string[] args)
   cil managed
   {
    .entrypoint

    ...
\end{lstlisting}

\par Po wygenerowaniu nagłówka oraz deklaracji głównej funkcji, generowany jest kod inicjalizujący wszystkie używane zmienne w funkcji \texttt{Main}. Inicjalizacja realizowana jest przy pomocy instrukcji \texttt{.locals init()}, dla której jako argument podaje się typy oraz nazwy zmiennych.

\begin{lstlisting}[language=IL, caption={Kod deklaracji zmiennych lokalnych funkcji głównej}, label=alg:asm]
  ...
  .locals init(
      int32 v_a,
      int32 v_b,
      int32 v_c,
      int32 v_tmp_1,
      string v_tmp_2)
  ...
\end{lstlisting}

\par Po zakończeniu generowania funkcji głównej, w podobny sposób generowane są funkcje tworzone przez użytkownika. Do tego również używana jest instrukcja \texttt{.method} dla funkcji statycznej. W przypadku kiedy użytkownik nadał wartość zwracaną oraz argumenty funkcji, to używane są odpowiednie typy dla tych elementów. Tak jak w przypadku funkcji głównej, na samym początku również są inicjalizowane zmienne lokalne funkcji przy pomocy instrukcji \texttt{.locals init()}, a następnie przepisywane są wcześniej wygenerowane instrukcje. Podczas przepisywania instrukcji jest wykonywany postprocesing.

\begin{lstlisting}[language=IL, caption={Kod deklaracji przykładowej funkcji}, label=alg:asm]
  .method static int32 f_mul(
    int32 v_a, 
    int32 v_b) cil managed
  {
  .locals init(
        int32 v_sum,
        int32 v_tmp_0)
  ...
\end{lstlisting}

